[{"title":"Hello Ubuntu","url":"/2024/08/26/Hello-Ubuntu/","content":"这是一份自用的 Ubuntu 安装教程，不包含安装盘制作过程\n\n设备：Windows 11 PC\n版本：LTS 22.04\n安装前请确保磁盘分区格式为 GUID 分区表(GPT)\nHere we go~\n\n\n关闭 BitLocker 和独显直连\n\n\n压缩 Windows 分区\n\n\n插上U盘，进入 BIOS：\n(1) 关闭 Secure Boot\n(2) 关闭 Intel RST\n(3) 设置U盘引导\n\n\n安装 Ubuntu：\n(1) 在更新和其他软件中关闭安装 Ubuntu 时下载更新\n(2) 打开为图形或无线硬件......\n(3) 在安装类型中选择其他选项\n(4) 选中之前压缩的空闲分区，点击+，选择根挂载点\n(5) 选择 efi 分区的设备号，在下拉菜单中找到并选中\n(6) 点击现在安装\n\n\n后续步骤较为简单，略\n安装完成后记得在 BIOS 中设置 Ubuntu 引导\n","tags":["Linux"]},{"title":"Mate 60 Pro 使用体验报告","url":"/2023/11/11/Mate60Pro%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/","content":"这台手机也快用了两周，趁着热情还没消减来简单谈谈它。\n\n1 前言：从果粉到花粉\n2012年还是2013年的时候，我妈买了一台iPhone4s，大概在我记忆中这便是最初的智能手机，后来年长了几岁，她用上了iPhone6s，于是便将iPhone4s交给了我。就像这样，我从小到大依次用了iPhone4s，6s，X，而在4s到6s之间还用过一台Samsung Note 2（应该没记错名字），就在这个时候我接触了minecraft（当时还叫PE版）这个游戏，并且稍微学习了一些文件的知识（其实不算知识，只是基本技能而已），也稍微会用apkeditor（应该没记错）破解和修改一些apk文件。当时苹果的优势还不那么明显，以至于换到iPhone6s时直呼“这系统怎么这么封闭”，一不能访问文件，二不能下载盗版。不过这时候大概也上初中了，不想小学那么悠闲地每天放学都有时间折腾这折腾那，然后是2017年iPhoneX发布，其惊艳的外形和全新的手势让我妈在第一时间购入了64g版本，最后在2019年我妈换上了iPhone11ProMax，我才正式拿到了iPhoneX这台手机。\n\n\n不得不说，那时候的苹果相当于数码产品潮流引领者，一个等宽边距刘海全面屏，引得安卓阵营众品牌模仿，甚至在几年内能做成等宽边距的品牌都很少（也是个人感觉华为mate40外观上唯一美中不足的地方）；一个全面屏手势颠覆全球手机用户操作习惯，可苹果也没想到的是它引以为傲的“符合人体基本逻辑直觉”的全面屏手势却在现在被大家诟病。\n2017-2023，6年时间，安卓（鸿蒙）阵营卷相机、卷充电速度、卷续航，而苹果呢——从iPhone12开始就没变过的模具，从iPhone5s开始就没变过的接口（iPhone15换c口了哈哈），永远安全环保的充电速度，一天三充的超强续航……早在小米13ultra发布不久时，我就有更换手机的想法，不过考虑到小米13ultra各种蛋疼的点、对学生并不友好的售价、家里亲戚用小米品牌遇到的各种问题留下的坏印象等各种debuff，最后便放弃了。这时候华为mate60pro带着5g凯旋归来，在看完各种视频评测，在线下体验鸿蒙4.0+麒麟9000S之后，我原计划购买的比这更贵的iPhone14pro瞬间就不香了，最后我就选择了这台争气机。\n2 评测：只谈体验，不谈参数\n这一部分是出于我这个几年苹果用户的角度，我觉得用这种角度的体会才更能感受到华为的进步和其向苹果看齐的胆量。而当时手机到手时鸿蒙系统121版本已经推出了，我并没有怎么使用116系统就直接更新了，因此以下的体验均是在此基础之上的。\n2.1 优点\n\n充电好快！之前用苹果的时候我都得把手机放在下面充一晚上，不然白天可怜的续航会雪上加霜，而换手机之后如果没有早八的话我前一天晚上甚至可以不充电把手机带上床，然后第二天早醒来充电再去刷牙洗脸吃早餐，回来电就充满了。这还只是88w，别的安卓机120甚至200w的我想都不敢想。\n拍照好牛！一是因为之前手机毕竟好几年了加上镜头内部估计因为换电池弄脏了，成像画质不堪入目；二是因为遥遥领先的超级微距和华为相机最引以为傲的算法，让我有种自己是摄影大师的错觉。\n\n\n\n\n鸿蒙系统：超级中转站，智能识别，智感支付，智能防窥，搭载鲲鹏大模型的AI助手小艺，权限管理……虽然在各种动画的设计和系统层级逻辑上赶不上苹果，但无疑让人感受到科技的人文感，这不正是乔布斯所说的“站在科技与人文的十字路口”吗？\n消息提醒：归根结底还是系统的问题，苹果杀后台但鸿蒙不杀，以至于我苹果经常看漏消息，但用华为手机完全不用担心这点，并且在华为有 静音-震动-响铃 三个模式而苹果只有 响铃-静音 两种模式（静音默认震动，需要去设置里关），总之就是一个字——遥遥领先！\n灵犀通信：AJ，CJ，厕所，电梯，甚至是荒无人烟的山里（卫星通信），你能想到地方，全部都有信号！\n\n2.2 缺点\n\n系统动画：虽然鸿蒙4.0已经看得出来，在各个细节都下了功夫，有种果粉口中所谓的“苹果特有的高级感”，但是毕竟苹果的动画优先级最高，所以二者终归还是有差距的。华为的动画在省电模式时有明显卡顿，因为刷新率变为了60Hz，而苹果60Hz的动画却能够做到90Hz的效果；华为的打开界面会存在顶部状态栏闪烁而非苹果的丝滑过度；华为app内动画逻辑不统一，不过这点毕竟不像苹果有一整套详细的动画规定和严格的应用商店app审核机制，所以无法避免也能谅解。\n发热：火麒麟终究是火麒麟，在AJ上课时可能是出于信号差的原因，明明只是QQ水群手机发烫却异常厉害，不过好在火麒麟有超大散热片压制，并没有像苹果那样烫手，不过刷QQ就发热这种事情多少是会影像体验的。\n系统bug：目前我发现的bug有 QQ动图的播放速度会根据屏幕上出现动图的数量增多而变慢 华为默认鸿蒙Emoji在某些地方显示时时而是鸿蒙emoji时而是苹果emoji，不过这些bug其实都并没有特别影响使用，所以说鸿蒙系统工程师到底有多少头发？\n尺寸：太大了！太大了！太大了！我算是手很大的人但是根本拿不住，这应该是旗舰机里最宽的手机了，不知道是出于何种原因华为把这个手机尺寸做的这么大，真的只能双手使用，单手使用太蛋疼。\n全天候显示：并不像IOS一样可以把图的主题部分抠出来然后1Hz显示，而是一整块壁纸放暗然后显示，并且还只支持默认的少数壁纸，正常面部解锁时暗到亮衔接别扭，指纹解锁更是整块变黑再变亮，被窝里刷手机真的晃瞎我。\n广告：默认第三方app都快20个！系统app内置广告！刚拿到手没关各种广告的一天收到一堆没用的通知！虽然听说mate60的广告比其他华为手机少，但我真的不觉得这是一个优秀旗舰机会出现的东西，而且我关广告足足关了快10分钟！10分钟！系统app在关掉广告后还经常会以“给予更好地个性化服务”为由询问你是否打开广告。\n\n2.3 总结\n拿到这台手机，颇有当年第一次见到iPhoneX的惊艳，它或许不能像iPhoneX一样引领全球数码产品发展潮流，但也注定是和iPhoneX同等地位甚至更高地位的值得载入智能手机发展史的一部手机。\n3 后记：激动过后的思考\n一个私有企业将自己的品牌绑定在民族情怀上的做法，我认为并不可取，但华为能以（实）力服人，真正突破封锁，不说空话脚踏实地（点名表扬一下某国产自研IDE），这些都是无比难能可贵的。但手机本来是应该作为一部通讯工具，却在有意无意之间被蒙上了消费主义的色彩。当一部部光鲜亮丽的电子屏幕整齐地摆放在昂贵的展示桌上，人的价值似乎被异化了，几年前乃至几年之后的苹果是如此，而华为亦是如此。为了换个手机，我曾在多次上课时摸鱼抢购，也曾在课后挤压宝贵的学习时间观看各类评测视频，甚至是现在宝贵的假期我也在写这篇不知道会有多少人看的文章。这部手机和其他的高端消费品一样不可避免地被蒙上了消费主义的色彩，但我肯定不会后悔买这部手机，也绝对不会觉得这部手机低性价比。\n————-祖传分割线————-\n本来是想在后记里写这台手机的意义的，奈何表达能力有限，并且个人也不太喜欢说一些过于宏大而正能量的话，因此还是改成激动过后一些不太深度的思考。\n————-祖传分割线————-\n2024/2/13补充：Nova11SE华为你干的好啊，“高端看创新，低端看良心”，你可不要成为下一个联想。\n","tags":["杂谈"]},{"title":"Hello World","url":"/2004/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","tags":["hexo"]},{"title":"论拱白菜的土猪","url":"/2021/09/11/%E8%AE%BA%E6%8B%B1%E7%99%BD%E8%8F%9C%E7%9A%84%E5%9C%9F%E7%8C%AA/","content":"看了张锡峰学长的“土猪拱白菜”演讲，我深感鼓舞。可细品其演讲稿，读完前三段我便陷入了沉思：\n\n为什么“小小乡村”的学生能够进入衡水中学？我上网查阅得知，衡水普通学生一学期学费将近一万，复读和外省学生一学期学费将近两万五，这是我这个小康家庭孩子想都不敢想的数字。一万一学期的学费相当于我所在的高中两年的学费，那么张锡峰学长真的经历过他所讲的“教育资源的匮乏”吗？若他所讲并非事实，那么他是否就是演讲稿后文所说的“假装”“作秀”呢？但如果他说的是真的，那么就有可能是资本家将其作为流量，将其变现，他的家庭也因此富裕起来。昨天我在网上看到他登上他家的豪车的视频，从评论里还了解到，衡水中学校外家长的车中这还算是较为普通的，其他大多都是天文数字的只存在于我们普通人调侃中的品牌汽车。由此可知：他不是我们这种层次的普通人，至少现如今不是。\n继续往下读，便看到他演讲中最大的争议点。“他们神色匆匆，各自奔忙。拿着两三千元的薪水，过着周而复始循规蹈矩的生活。一眼就能看到死。那种深邃，那种空洞，让我第一次感受到恐惧！”两三千元的薪水，一眼看到死，是不是说那些（我观念中的）中产阶级都是推动社会进步的燃料？燃烧殆尽便是一堆没有个性，没有用处的废渣？我的父母工资是两三千元，但他们并没有“一眼看到死”，如演讲稿后文所说，他们将希望寄托于我，希望我改变家族的命运。你说那些空洞的“死人”暂时没有孩子以寄托希望？我想问平凡不能造就伟大吗？《平凡的世界》中孙少平虽然没有文凭没有学历，一样能收获令自己满意的爱情，一样能拥有对知识的渴望，白天在工地干完活夜晚悄悄看书，你说那是时代变了？外卖小哥洪成木能够在送餐期间帮助寻找走失的人，奉献并快乐着；电焊工李万君努力钻研着我们大部分人都瞧不起的工作，却创造出20多项焊接操作法，申请多项专利，得到国家认可；胡胜是一位车床加工工人，是全厂对刀具最精通的人，获“大国工匠”之美誉……平凡也能造就伟大！但是这篇演讲给人的感觉就是“我生于平凡，我痛恨平凡，我想摆脱平凡”，怀着这样的思想，如果张锡峰学长成为“社会精英”，是否会成为啃着无产阶级人血馒头的资本家？国家的强大是全体人民群众共同创造的，每一个人都不可或缺，因此我认为我们没有权利去批判那些平凡的人，去鄙视平凡的人，甚至去憎恨平凡的人。借同学一言“张桂梅女校的学生在采访中直接表达‘一点一点的为身边人付出 一点一点的为社会付出’，而某水中学却把学生的思维变成了‘一点一点的把身边的人踩下去 一点一点的垄断社会资源 成为人上人’”。\n那么问题出在哪里？我更倾向于张锡峰不是“作秀者”而是受害者，也看了不少评论这场演讲的文章，貌似所有的矛头都指向了衡水中学——高考加工厂。演讲中说衡水的学子不是高考机器，而是想成为父母的骄傲，的确如此，但是衡水中学的“精神胜利法”是否有问题？教育部所言“德智体美劳全面发展”教育，到了衡水怎么成为了通过高考不择手段成为人上人教育？我无法否认衡水的教学质量，毕竟我所在的高中是市内前几，同样用着衡水的资料，但是衡水这种错误的精神胜利法，给人的感觉难度不就是“高考加工厂”吗？我作为学生没有资格评判全国的教育制度，但我可以作为一个旁观者评价衡水中学的制度。我希望“高考加工厂”中走出来的学子们能考出好成绩并真正为社会服务，成为国家栋梁，而不是变成加工出来的产品，成为披着优秀成绩外衣的衣冠禽兽，蔑视着平凡者并压榨着平凡者。\n————-分割线————-\n高二时写的垃圾，最近会逐渐上传一些很久以前写的还算有意思的东西。（上传于2023/10/14）\n","tags":["杂谈"]},{"title":"浅谈形式主义","url":"/2023/10/01/%E6%B5%85%E8%B0%88%E5%BD%A2%E5%BC%8F%E4%B8%BB%E4%B9%89/","content":"网上有人这样评价大学：大学是形式主义最严重的地方。\n\n包括我在内的很多大学生对此都表示赞同，甚至一度有同学将“努力办好让人民满意的高等教育”的标语图片PS成“努力办好让领导满意的形式主义”。对于这样的现象，早在大一入学一两个月时就打算写一篇长文对此现象进行批判，奈何本人才浅学疏，又是一个胸无笔墨的工科生，本来就不强的写作能力也在高中毕业后逐渐消亡殆尽，实在是感谢《马克思主义基本原理》这门课，给了我这样一个机会得以表达自己的感受和一些肤浅的见解。\n先让我们明确一下形式主义的定义：形式主义，指的是一种只看事物的表象而不加分析其本质的思想方法和工作作风。现代中国形式主义最著名的事件莫过于“亩产三万五千斤”，具体反应到我们的生活中可就太多了：从小到大，学校一旦有领导来检查我们就必须表现得怎样怎样好，城市一旦要评“全国文明城市”，各种各样的要求和口号就通过各种各样的媒介进入我们的眼中，进入大学后我竞选成为了班级的学习委员，这样一来入党时能方便不少。在成为学习委员后，学院下发了各种各样的班委任务，其中一个学习委员的任务是“学风督导”——在每周几个固定的时间禁止宿舍内同学娱乐并要求他们学习。其实客观而言，强制要求大学生来学习这件事本身就不现实，奈何当时的我过于天真，在班级qq群内和同学们讨论过后确定了几个时间并且每到这个时间我就逐个寝室去检查，期间记下了不少不按规定来的同学的名字，也和同学们起了冲突。后来班长包括是辅导员都找到我说，没必要这么认真地去执行这件事，摆拍一两张照片随便应付就行了，考虑到这样方便自己还不用受气我就照做了。而经过交谈后我也了解到，全年级认真执行这件事的学习委员只有少数几个，相信在经历过各种磨合之后他们也会和我一样，将这件事情应付了事。以上只是刚入学令我印象最深的一件事，后来诸如此类的事情还有很多，什么班级团日活动从一开始的认真举办吃力不讨好到后来的摆拍抄材料获得表扬，什么平时一直翘《思想道德与法治》最后认真考试一样4.0，什么《大学物理实验》原理都不会但照葫芦画瓢考试抱佛脚一样4.0……我也逐渐变成了一个熟练把玩形式主义的老油条，但是回顾这些事情，我就不禁会怀疑，我虽然将花在这些事情的时间减少了，但我得到了什么，如果我不去应付这些事情而是认真对待，我又是否能真的得到我需要的知识和技能。但可惜的是，我不知道如何改正这些在我认知底层所认为的不正确的事情，又或者说，我现在所做的应付又或许是应对这些事情最好的方法，我可以把本来应该认真对待这些事情的时间花在更重要的课程上，花在我个人的娱乐消遣上。就我一个人的成长经历而言，如此多的事情都能或多或少与形式主义挂上钩，更不用谈我们的社会和政治。总而言之，形式主义会产生很多没有必要的事情，让真正有用的事情没办法\n然后我们接下来来探讨形式主义的根源。形式主义的产生，有其思想理论基础和社会历史根源，思想理论基础是唯心主义形而上学，社会历史根源是习惯势力和传统文化负面影响，具体到一个单位形式主义产生的根源有二：一是名利思想，功利主义的私心是滋生形式主义温床；二是懒惰作风，惰性引发飘浮思想，只管形式，红火，喜欢把功夫下在形式上，只管快，不管效果怎样。就继续拿上文中我的经历举例吧，这其中的形式主义究竟是谁引发的？是“不谙民情”的校领导吗？是教人做事的辅导员吗？是思政课的授课老师吗？又或者，是我们自己？我们总是自然而然的把自己的错误推到别人身上，但我们嘴上一个接一个的批判形式主义，如果不考虑认真对待那些形式主义能解决的事情所消耗精力的不合理，我们不是也一样和形式主义者们同流合污了吗？因为能用懒惰地做最少的事情得到最好的名利思想，并且大家都是这样，我们便也将这种事情视为了理所当然。\n最后说说形式主义的解决方法吧。我认为根治形式主义要思想和实际行动两手抓。思想上，我认为自上而下的所有人都应该保持清醒，上层不能沉醉在自己的世界而不切实际地提出过多要求，中层不能不负责任地向下推卸责任，下层也要破处惰性的思想，欺瞒自己也欺瞒上层。实际行动上，习近平总书记多次就破除形式主义作出重要批示，要求各级机关和领导干部从自身做起，带头反对形式主义，为基层减压减负。我认为这是正确的。如果把一件事情的执行作为一个链条（下面简称“执行链”），那么链条顶端反对形式主义并进行减负，才让基层有了认真对待而非形式主义处理的可能，除此之外，执行链的每一个结点也是很重要的，他们需要认真完成好自己的任务而非将自己的任务施加给下一个结点，否则随着任务的堆积，执行链顶端最开始减压减负的目的便无法完成。当然以上这些看上去很空很泛，但如何根治形式主义确实是我们每一个处在形式主义大环境下的普通人和党自我革命的重要课题。\n这篇文章也算不上什么深度解析，最多也就是一个普通人发的一点牢骚和一些拙劣的见解罢了。或许我作为一个同流合污的形式主义者没有资格探讨和批判形式主义，但作为一名基层群众，我认为通过实际行动来解决形式主义，才有助于改善中国的教育和社会环境。很多人拿形式主义去批判中国共产党，但我还是心怀希望，希望党的自我革命能够顺利完成，破除形式主义的不良风气，即使这个过程可能会很漫长。\n————-分割线————-\n以上是《马克思主义基本原理》课程的作业，难得的一次没有依赖ctrl c+v完成的作业，自己读起来实在是依托答辩。\n如果有不同的见解或者更好的建议，欢迎与我探讨！\n","tags":["杂谈"]},{"title":"操作系统研讨笔记","url":"/2024/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A0%94%E8%AE%A8%E7%AC%94%E8%AE%B0/","content":"操作系统课上研讨做的笔记，觉得对考试/面试有用所以传上来了，因为都是同学们做的研讨，可能会有一些小错误，如果发现了错误欢迎联系我~\n\n主题一：操作系统的硬件接口与 Linux 系统\n1、简述微处理器的发展里程，简述 80386 架构的主要寄存器组 ，举例说明指令执行的一般过程。\n微处理器的发展：\n可以概括为五个阶段，从最早的 Intel 4004 到现如今的异构多核处理器。\n\n80836 架构的主要寄存器组：\n共有 7 类 34 个寄存器，包括 8 个通用寄存器及其他一系列寄存器。\n\n值得注意的是，我们常说的例如 PC 寄存器等并非是指某一个特定的物理上的寄存器，而是用于实现特定功能的多个寄存器。例如：在 80836 架构中，PC 寄存器由段寄存器 CS 和指令指针寄存器 EIP 组成。\n指令执行的一般过程：\n由取之周期、间址周期、执行周期和中断周期组成。\n\n2、描述 x86 中实模式和保护模式的寻址区别，并说明在这两种模式中逻辑地址、线性地址和物理地址的关系。 IA32 中提供了哪些机制来帮助实现安全可靠的多任务多用户的操作系统。\n概念扫盲：\n\n\nx86 是广泛使用的处理器架构，基于 32 位指令集。\n\n\n实模式全称是实地址访问模式。\n\n\n保护模式全称虚拟地址保护模式。\n\n\n逻辑地址是程序占有的虚拟存储器的地址。\n\n\n线性地址是段中的偏移地址，加上相应段的基地址。\n\n\n物理地址是物理存储器的实际地址。\n\n\nIA32: Intel Architecture 32-bit，也称 x86-32\n\n\nx86 中实模式和保护模式的寻址区别：\n\n实模式下处理器使用 16 位寄存器来表示内存地址，导致寻址空间最大为 1 MB，通常用于加载操作系统和应用程序的指令与数据；实模式有简单的分段机制，每个段的大小为 64 KB，段地址由段寄存器决定；物理地址 = (段地址 x 16) + 偏移地址；内存空间共享，无保护，寻址空间小。\n虚模式下逻辑地址经过段选择符和段描述符变为线性地址；线性地址通过分页机制映射到物理地址。\n\n两种模式中逻辑地址、线性地址和物理地址的关系：\n\n\nIA32 提供的用来帮助实现安全可靠的多任务多用户的操作系统的机制：\n\n\n段保护机制：每个段都有明确的边界和访问权限，防止程序越界或非法访问其他进程的内存区域。\n\n\n分页机制：内存隔离。\n\n\n特权级别：系统态、用户态。用户态不能执行 OS 指令。\n\n\n任务状态段 (Task State Segment, TSS)：每个任务都有一个对应的 TSS，操作系统可以通过 TSS 来保存和恢复任务的执行状态，实现快速任务切换。\n\n\n3、简述异常和中断的概念，说明 intel 80386 架构中的中断类型，比较 x86 架构中实模式和保护模式中的中断机制。\n异常：异常是程序运行过程中发生的意外情况，通常由 CPU 执行指令时遇到的问题引发。 异常是同步事件。\n中断：中断通常是由外部设备或系统设置触发的，它是通过暂停当前事件的处理来响应外部事件的请求。中断是异步事件。\nintel 80386 架构中的中断类型：\n\n外部中断：外部中断由外部设备或事件引起，例如键盘按键、鼠标移动、定时器溢出等。\n非屏蔽中断：非屏蔽中断优先级最高，即使中断屏蔽位IF为0，CPU也会响应。\n软件中断：软件中断通过指令触发，由软件控制，用于执行特殊功能或请求系统服务。\n\nx86 架构中实模式和保护模式中的中断机制：\n\n\n\n特征\n实模式\n保护模式\n\n\n\n\n中断向量表\n1KB 的固定内存区域\n可配置的描述符表\n\n\n中断处理程序地址\n直接存储在中断向量表中\n存储在中断描述符表中，包含访问权限信息\n\n\n中断过程\n简单跳转到中断处理程序地址\n使用门，进行更复杂的处理\n\n\n优点\n简单易懂，实现成本低，适合早期系统\n安全性高，可管理性强，可扩展性强，支持多任务处理\n\n\n缺点\n安全性较差，难以管理、扩展\n实现复杂，需要更多的资源，对硬件要求更高\n\n\n\n实模式中断处理过程：\n\n保护模式中断处理过程：\n\n4、简介 PC 体系结构中中断控制器芯片 8259a ，描述其工作原理。\n8259a 简介：\n开发背景：8259a 是由英特尔公司在20世纪80年代早期设计推出的。它的出现是为了解决当时 PC 体系结构中多个设备中断请求的管理问题。\n中断处理器的定义：中断控制器是计算机硬件的一部分，负责管理来自不同硬件设备的中断请求。它确保CPU能够及时响应这些外部事件，执行相应的处理程序。\n功能特点：\n\n\n优先级管理\n\n\n自动结束中断\n\n\n可编程性\n\n\n联机能力\n\n\n对比 8524：与8254定时器/计数器等其他类型的硬件控制器相比，8259A专门用于中断管理，而8254则主要用于定时和计数功能。\n硬件和组成结构：\n\n工作原理：\n\n\n中断请求的识别和优先级处理\n(1) 硬件设备发出中断请求\n(2) 8259A 识别请求并确定优先级\n\n\n中断服务程序的调用过程\n(3) 8259A 向 CPU 发送中断信号\n(4) CPU保存当前任务状态\n(5) CPU跳转到 IVT 中指定的 ISR\n(6) 执行 ISR\n(7) 8259a 发送中断结束信号（EOI）\n(8) CPU恢复之前任务的状态\n(9) CPU返回到被中断的任务继续执行\n\n\n编程控制字（ICW）和操作控制字（OCW）：ICW 用于初始 8259a，OCW 用于控制 8259a 的行为\n\n\n中断向量表（IVT）：包含所有中断程序入口的地址\n\n\n5、PC 体系结构中用来提供时钟中断的外部芯片是什么？简介其工作原理，分析时钟中断对操作系统运行的作用。\nPC 体系结构中用来提供时钟中断的外部芯片是 PIT（可编程间隔计时器），它主要用于生成定时信号，控制系统中的定时事件。核心功能是通过硬件计时器产生时钟中断，从而触发操作系统执行相应的处理。\nPIT 的工作原理：\n写操作（CPU -&gt; PIT）\n\n读操作（PIT -&gt; CPU）：写入计数值时需要通过D0-D7两次传输（分别传输低字节和高字节）传输方式由控制字中的RW1、RW0指定。CPU也可以通过D0-D7读取计数器的状态信息，如当前计数器的值、计数器是否处于倒计时状态等。\n时钟中断：时钟中断是指在计算机CMOS中一个芯片晶片中（常被称为实时时钟）由电池供电，用于计时，而另一个芯片则根据实时时钟提供的时间定期向CPU引脚发送中断信号的中断。\n对操作系统运行的作用：时钟中断是指在计算机CMOS中一个芯片晶片中（常被称为实时时钟）由电池供电，用于计时，而另一个芯片则根据实时时钟提供的时间定期向CPU引脚发送中断信号的中断。\n6、简述Linux的启动过程的关键步骤，并且和Windows系统作比较。\nLinux 启动过程的关键步骤：\n\n硬件自检\n引导加载程序（GRUB 程序）\n内核加载\n用户空间初始化\n登陆界面\n\n比较：\nLinux 和 Windows 的启动过程主要区别在于引导加载器和系统初始化。Windows 使用 Windows Boot Manager，通过 BCD 配置文件加载内核，并启动关键进程如 SMSS.exe。Linux 通常使用 GRUB 加载内核及 initramfs，然后通过 systemd 或 SysVinit 初始化系统服务。Windows 依赖专有机制，而 Linux 提供更灵活的引导和服务管理方式，支持多操作系统引导。\n7、什么是Shell？简述Shell运行的过程，并举例说明。Shell脚本与一般高级语言程序有何不同？\n什么是 Shell：\nShell 是命令语言、命令解释程序及程序设计语言的统称，也是命令语言解释器，用户和 Linux 内核之间的接口程序。\n\nShell 运行的过程：\n\nShell 脚本与一般高级语言程序的不同：\n\n\n\n\nShell 脚本\n一般高级语言\n\n\n\n\n语言类型\n解释型语言\n既有编译型语言也有解释型语言\n\n\n主要用途\n自动化系统任务和日常管理\n开发各种复杂的应用程序\n\n\n支持\n主要在 Unix/Linux 系统中使用，WIndows 支持较为有限\n具有良好的跨平台支持\n\n\n数据处理能力\n有限\n更强大\n\n\n错误处理\n简单\n更完善的机制和调试工具\n\n\n\n8、Linux/Unix的进程家族树的概念介绍？演示Linux操作系统下面查看进程树的命令？\n概念引入：\n父子进程：每个进程可以创建一个或多个子进程。子进程是由一个已存在的进程（父进程）通过系统调用 fork() 创建的。系统中的每一个进程都必然有一个父进程，有零个或者多个子进程，拥有同一个父进程的所有进程被称为兄弟，进程间的关系也被存放在进程描述符中。\n\n各类 ID：\n\n进程家族树：系统中的每一个进程都必然有一个父进程，有零个或者多个子进程，拥有同一个父进程的所有进程被称为兄弟。\n\nLinux 操作系统下面查看进程树的命令：\n$ ps axjf# a：显示当前控制终端上的所有进程。x：显示后台进程，而且不限于当前终端。j：输出为树形，显示进程家族关系。f：显示进程家族树。\n$ pstree -gp# g：显示 PGID。p：显示 PID。\n可以通过fork()、exec()、wait()、exit()等进程函数来通过编程管理父子进程。\n9、请归纳并给出Linux环境以下信息获取的方法：读取指定进程的进程信息、 获取总线信息、 获取内核所使用设备信息、 获取系统所引入的NFS文件系统信息、 获取IDE设备信息、 获取IRQ信息、 获取网络信息、 获取SCSI设备信息、获取系统信息和获取TTY设备信息。\n读取指定进程的进程信息：\n# xxx 可填 status, cmdline, environ, smpas...$ cat /proc/&lt;PID&gt;/xxx\n获取总线信息：\n$ lspci\n获取内核所使用设备信息：\n\n设备驱动\n\n$ lsmod\n\n消息缓冲区\n\n$ sudo dmesg | grep -i &#x27;device&#x27;\n\n硬件配置信息\n\n$ sudo lshw\n\n特定设备详细信息\n\n$ udevadm info --query=all --name=/dev/nvme0n1p5\n获取系统所引入的 NFS 文件系统（网络文件系统）信息：\n$ mount | grep nfs\n$ cat /proc/mounts | grep nfs\n获取 IDE 设备（过时，现多用 SATA 或 NVMe）信息：\n$ sudo hdparm -i /dev/hda\n$ cat /proc/ide/hda/model\n获取 IRQ 信息：\n$ cat /proc/interrupts  \n$ lsirp \n获取网络信息：\n$ ifconfig\n$ ip a\n获取 SCSI 设备信息：\n$ cat /proc/scsi/scsi\n$ lsscsi\n获取系统信息：\n\n系统内核信息\n\n$ uname -a\n\n发行版信息\n\n$ lsb_release -a\n\n第三方工具一网打尽\n\n$ fastfetch\n获取 TTY 设备信息：\n$ cat /proc/tty/drivers\n$ tty\n10、Linux环境下进程信息查看和作业控制：虚拟终端1（root用户）利用vi新建f1.txt文件，将vi作业挂起；后台启动find进程；显示当前所有作业和进程号；显示所有进程含优先级的进程详细信息，并画出进程家族树后，中止find进程的后台运行。虚拟终端2（student用户）启用vi新建f2.txt文件,其优先级为5, 后台启动find进程，显示含优先级的进程详细信息；再将student用户进程的优先数改为-5，显示含优先级的进程详细信息。写出相应操作步骤。\n# 在虚拟终端1（root用户）：$ vi f1.txt # 新建f1.txt文件# Ctrl+Z（挂起vi作业）$ find / -name “*.txt” &amp; # 后台启动find进程$ jobs # 显示当前所有作业$ ps –ef # 查看所有运行中的进程及其进程号$ ps -eo pid,ppid,cmd,pri,ni # 显示所有进程含优先级的进程详细信息$ Pstree -p # 画出进程家族树$ kill %&lt;find作业号&gt; # 中止find进程\n# 在虚拟终端2（student用户）：$ nice -n 5 vi f2.txt # 新建f2.txt文件，优先级为5$ find / -name “*.txt” &amp; # 后台启动find进程$ ps -eo pid,ppid,cmd,pri,ni # 显示含优先级的进程详细信息$ sudo renice -n -5 -u student # 将student用户进程优先数改为-5$ ps -eo pid,ppid,cmd,pri,ni # 再次显示含优先级的进程详细信息\n拓展：为了更明显地体现进程优先级（niceness 值）对进程执行的影响，可以将两个进程都限制在同一个 CPU 核心上运行。这样，在只有一个 CPU 核心可用的情况下，进程的优先级对 CPU 资源的分配影响会更加显著。\n# 打开第一个终端$ taskset -c 0 yes &gt; /dev/null &amp;\n# 打开第二个终端$ taskset -c 0 nice -n 10 yes &gt; /dev/null\n# 打开第三个终端$ htop\n在 htop 界面中，会发现：\n\nCPU 0 的使用率接近 100%，因为两个高负载进程都在运行。\n默认优先级的 yes 进程占用的 CPU 资源更多。\n降低优先级的 yes 进程占用的 CPU 资源较少。\n\n主题二：进程管理\n1、Linux环境下用户间非实时通信\n(1) root用户向student用户发送一封邮件，内容为“请尽快上交实验一：Linux的桌面环境及基本shell命令的实验报告。”，主题是“催交实验报告”，并请转发给hellen用户。student用户阅读邮件后，回复“知道”，并将发来的信件保存为文件vipletter后删除该邮件。最后退出mail，检查mbox文件，并分析说明检查结果。写出相应操作步骤。\n(2) 假定在进程通信中我们使用一个类似邮箱的机制。当一个进程试图往一个满箱放东西的时候，或者从一个空箱拿东西的时候，该进程并不阻塞。而是得到一个错误返回码。该进程立即重复上述过程（往邮箱里放东西或者从邮箱里拿东西），直到成功为止。请问这种机制会造成竞争吗？为什么？\n(1) 以 Ubuntu 22.04 操作系统配合 mailutils 实现\n在 Settings-Users 中新建两个用户：student 和 hellen\n$ sudo apt update$ sudo apt install mailutils$ sudo su$ mail studentCc: helenSubject: 催交实验报告请尽快上交实验一：Linux的桌面环境及基本shell命令的实验报告。\n这里的 Cc (Carbon Copy) 即抄送，填入转发对象，上述内容输入完成后换行，按 Ctrl+D 发送\n切换到 student 用户\n$ su student$ mail&quot;/var/mail/student&quot;: 1 message 1 new&gt;N\t1 root\t\t\t\tSun Oct 13 17:06\t14/500\t催交实验报告\n所有未读邮件保存在 /var/mail/&lt;user&gt; 路径下\n从左到右依次为：邮件状态、编号、发送者、日期、主题\n邮件状态有 N（新邮件）、U（未读）、R（已读）、*（已保存）等\n接下来打开邮件\n? 1Return-Path: &lt;root@ubuntu&gt;X-Original-To: studentDelivered-To: student@ubuntu.localdomain&quot;Received: by ubuntu.localdomain (Postfix, from userid o)id A4FCA3362B; Sun, 13 Oct 2024 17:06:56 +0800 (CST)To: student@ubuntu.localdomainCc: helen@ubuntu.localdomainSubject: 催交实验报告User-Agent: mail (GNU Mailutils 3.17)Date: Sun, 13 Oct 2024 17:06:56 +0800Message-Id: &lt;20241013090656.A4FCA3362B@ubuntu. localdomain›From: root ‹root@ubuntu&gt;请尽快上交实验一：Linux的桌面环境及基本shell命令的实验报告。? r 1To: &quot;root&quot; &lt;root@ubuntu&gt;,&lt;student@ubuntu.localdomain&gt;Cc: &lt;helen@ubuntu.locaoldomain&gt;Subject: Re: 催交实验报告知道? q\n切换回 root 用户\n$ exit$ mail&quot;/var/mail/root&quot;: 1 messages 1 new&gt;N\t1 student\t\t\tSun Oct 13 17:10\t17/661\tRe: 催交实验报告\n切换到 helen 用户确认收到\n$ su helen$ mail&quot;/var/mail/helen&quot;: 2 messages 2 new&gt;N\t1 root\t\t\t\tSun Oct 13 17:06\t14/496\t催交实验报告 N\t2 student\t\t\tSun Oct 13 17:10\t17/687\tRe: 催交实验报告\n再切换回 student 用户\n$ exit$ su student$ mail&gt;U\t1 root\t\t\t\tSun Oct 13 17:06\t14/496\t催交实验报告 U\t2 student\t\t\tSun Oct 13 17:10\t17/687\tRe: 催交实验报告? s 1 vipletter&quot;/home/student/vipletter&quot;\t14/496? d 1? h &gt;U\t2 student\t\t\tSun Oct 13 17:10\t17/687\tRe: 催交实验报告? q$ mail -f mbox&quot;/home/student/mbox&quot;: 0 messages\n对于收到的邮件，默认保存在：\n\n\nN和U（新邮件和未读邮件）暂时挂在：/var/mail/&lt;user&gt;\n\n\nR（已读邮件）在退出mail后自动保存在：/root/mbox或/home/&lt;user&gt;/mbox\n\n\n*（已存文件）在保存邮件后查看为星号，保存在自定义路径里。比如演示中的/home/&lt;user&gt;/vipletter\n\n\n(2) 错误返回码没有解决竞态条件的根本问题，仍会导致反复竞争，进程的反复操作还可能占用系统资源\n2、无名管道通信的应用\n(1) 利用一条管道命令实现统计指定目录中子目录和文件的总数，并将统计结果保存到指定的文件中。\n(2) 利用一条管道命令实现将一封来自键盘的邮件发给用户USER1、USER2，邮件内容自定。\n(3) 管道通信的编程题：无名管道通信的实例分析。编写一算法，建立一个管道。同时，父进程生成子进程P1、P2，这两个子进程分别向管道中写入各自的字符串，父进程读出它们，其原理如下图所示。\n无名管道通信：一种进程间通信方式（半双工，即数据只能在一个方向上流动），主要用于具有亲缘关系的进程（因为无名，不能再文件系统中被访问）之间进行数据传输。\n创建和使用（pipe()，pipe2()）（pipe2() 相较于 pipe() 可添加 flag 参数）\n(1)\n$ find ~ -type f -or -type d | wc -l &gt; ./output_file.txt\n(2)\n$ echo &quot;content&quot; | mail -s &quot;title&quot; USER1 USER2\n(3)\n原理图：\n\n分析：\n当调用 pipe() 系统调用创建一个无名管道时，操作系统为管道分配了两个文件描述符和一块内存缓冲区\n- fildes[0]：管道的读端，用于从管道中读取数据。\n- fildes[1]：管道的写端，用于向管道中写入数据。\n数据在管道中是单向流动的，即数据只能从写端流向读端，无法反向传输。\n使用fork()创建子进程、exit()退出子进程，wait()等待子进程退出\nread(int __fd,void * __buf,size_t __nbytes (aka unsigned long)）\nwrite(int __fd,const void * __buf,size_t __n (aka unsigned long) )向缓冲区读和写close()关闭读或写端。\n代码：\n#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;int main()&#123;  int fildes[2];  char buf[64];  if(pipe(fildes)==0)&#123;    if(fork()==0)&#123;      printf(&quot;son1:my pid is %d,my ppid is %d\\n&quot;,getpid(),getppid());      strcpy(buf,&quot;hello,i am son 1&quot;);      write(fildes[1],buf,strlen(buf)+1);      close(fildes[1]);      exit(0);    &#125;else&#123;      wait(0);      read(fildes[0],buf,sizeof(buf));      printf(&quot;parent %d recevied:%s\\n&quot;,getpid(),buf);    &#125;        if(fork()==0)&#123;      printf(&quot;son2:my pid is %d,my ppid is %d\\n&quot;,getpid(),getppid());      strcpy(buf,&quot;hello,i am son 2&quot;);      write(fildes[1],buf,strlen(buf)+1);      close(fildes[1]);      exit(0);    &#125;else&#123;      wait(0);      read(fildes[0],buf,sizeof(buf));      printf(&quot;parent %d recevied:%s\\n&quot;,getpid(),buf);    &#125;    close(fildes[0]);  &#125;else&#123;    printf(&quot;create pipe failed!\\n&quot;);  &#125;  return 0;&#125;\n所谓“读者-写者问题”是指保证一个Writer进程必须与其他进程互斥地访问共享对象的同步问题。为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。另外，再设置一个整型变量Readcount表示正在读的进程数目。由于只要有一个Reader进程在读，便不允许Writer进程去写。因此，仅当Readcount=0, 表示尚无Reader进程在读时，Reader进程才需要执行P(Wmutex)操作。若P(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行V(Wmutex)操作，以便让Writer进程写。又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，应该为它设置一个互斥信号量rmutex。\n3、“读者-写者问题”扩展一：利用记录型信号量集解决读者-写者问题。\n读者-写者问题：\n一个数据文件或记录可以被多个进程共享，我们把只读该文件的进程称为“读者进程”，其他进程为“写者进程”。要求如下。\n(1) 允许多个读者可以同时对文件执行读操作\n(2) 只允许一个写者往文件中写信息，此时不允许其他读者或写者工作\n综上读者写者问题可以就是保证一个写者进程必须与其他进程互斥的访问共享对象的同步问题。\n读者优先的含义：\n读者进程的优先级高于写者进程，具体表现为当有读者正在读文件时，后面分别有写者和读者申请读文件，而即使后面的写者比读者先来也会优先让读者先读，直到所有读者读完，写者才会开始写，也就是说——写者进入“忙等”\n举例来说就是\n进程申请访问资源顺序为：\n读者 1 -&gt; 写者 1 -&gt; 读者 2 -&gt; （后面只有读者）… -&gt; 读者 n\n实际对资源操作的顺序为：\n读者 1 -&gt; 读者 2 -&gt; …  -&gt; 读者 n -&gt; 写者 1\n“读者优先”算法（伪代码）：\nint max_reader; \t\t\t\t\t\t\t\t\t\t\t// 最大读者数semaphore reader_left = max_reader; \t// 剩余可进入的读者数semaphore rw_mutex = 1; \t\t\t\t\t\t\t// 使读写互斥void reader()\t// 读者进程&#123;    while (1)    &#123;        Swait(reader_left, 1, 1, rw_mutex, 1, 0);       \t// 是否达到最大读者数，若是则阻塞当前读者；检查是否存在“读上锁”        perform read operation;        Ssignal(reader_left, 1);   \t\t\t\t// 释放读者数资源    &#125;&#125;void writer()\t// 写者进程&#123;    while (1)    &#123;        Swait(rw_mutex, 1, 1, reader_left, max_reader, 0); \t\t\t\t// 是否有人在读、写文件        perform write operation;        Ssignal(rw_mutex, 1); \t\t\t\t// 解锁    &#125;&#125;\n4、“读者-写者问题”扩展二：利用记录型信号量分别给出“读写无优先、写者优先”问题的同步算法。\n”读优先”算法（伪代码）：\nint count = 0;\t\t\t\t// 记录当前读者数量semaphore mutex = 1;\t// 保护更新 count 变量时的互斥semaphore rw = 1;\t\t\t// 保证读者和写者互斥writer() &#123;  while (1) &#123;    P(rw);    Writing;    V(rw);  &#125;&#125;reader() &#123;  while (1) &#123;  \tP(mutex);     if (count == 0) &#123;      P(rw);    &#125;    count++;    V(mutex);    reading;    P(mutex);    count--;    if (count == 0) &#123;      V(rw);    &#125;    V(mutex);  &#125;&#125; \n上述算法潜在的问题：只要有读进程一直在读，写进程就要一直阻塞等待，可能“饿死”（也就是前面说过的“忙等”），所以要对算法进行改进，就有了“读写无优先”和“写优先”\n“读写无优先“算法（伪代码）：\nint count = 0;\t\t\t\t// 记录当前读者数量semaphore mutex = 1;\t// 保护更新 count 变量时的互斥semaphore rw = 1;\t\t\t// 保证读者和写者互斥semaphore w = 1;\t\t\t// 实现读者写者的顺序读写writer() &#123;  while (1) &#123;    P(w);    P(rw);    Writing;    V(rw);    V(w);  &#125;&#125;reader() &#123;\twhile (1) &#123;    P(w);    P(mutex);    if (count == 0) &#123;      P(rw);    &#125;    count++;    V(mutex);    V(w);    reading;    P(mutex);    count--;    if (count == 0) &#123;      V(rw);    &#125;    V(mutex);  &#125;&#125;\n&quot;写优先&quot;算法（伪代码）：\nint readcount=0;\t\t\t//记录当前有多少个读进程在访问文件int writecount=0:\t\t\t//当writecount=0，唤醒读者semaphore mutex1=1;\t\t//用于保证对readcount变量的互斥访问semaphore mutex2=1;\t\t//用于保证对writecount变量的互斥访问semaphore mutex=1;\t\t//用于保证写者之间的互斥访问，其他读者要进入rmutex之前需要在mutex上排队semaphore rmutex=1;\t\t//当有新写者来时，停止所有的读进程。semaphore wmutex=1;\t\t//实现对写操作地互斥访问reader () &#123;  while (1) &#123;    P（mutex); \t\t//实现写者优先访问，禁止读者在rmutex排队，保证一次只有一个读者进程访问rmutex    P（rmutex);\t\t//读者进程加锁    P（mutex);\t\t\t//互斥修改readcount变量    readcount++;    if (readcount == 1)\t\t\tP（wmutex);\t//当有读者进程执行读操作时，对写者进程加锁    V(mutex1);    V(rmutex);\t\t//读者进程解锁    V(mutex);    reading;    P(mutex1); \t\t//互斥修改readcount变量\t\treadcount--;\t\tif(readcount==0)\t\t\tV(wmutex);\t//当读者数量为0，解锁写者进程，允许写者进程执行写操作\t\tV(mutex1);  &#125;&#125;writer () &#123;\twhile (1) &#123;\t\tP(mutex2);\t\t//各写者进程互斥访问writecount    writecount++;\t//写进程数量+1\t\tif (writecount == 1)\t\t\tP(rmutex);\t//有写进程时，对读进程加锁\t\tV(mutex2);\t\tP(wmutex);\t\t//写之前加锁，保证每次只有一个写者可以进行写操作\t\twriting;\t\tV(wmutex);\t\tP(mutex2);\t\twritecount--;\t//每当有一个写进程完成写操作，写者数量-1\t\tif (writecount == 0)\t\t\tV(rmutex);\t//若没有写进程正在执行，解锁读者进程\t\tV(mutex2);&#125;\n5、“读者-写者问题”扩展三：利用记录型信号量集分别给出“读写无优先、写者优先”问题的同步算法。\n“读写无优先“的含义：\n读写无优先级，读和写的顺序严格按照进程申请访问资源的顺序来进行。\n举例来说就是\n进程申请访问资源顺序为：\n读者 1 -&gt; 写者 1 -&gt; 读者 2\n实际对资源操作的顺序就也是：\n读者 1 -&gt; 写者 1 -&gt; 读者 2\n为此，在读者优先算法的基础上加入 FCFS（First Come First Serve）信号量。\n“读写无优先”算法（伪代码）：\nint max_reader;semaphore reader_left = max_reader;semaphore rw_mutex = 1;semaphore FCFS = 1;reader()&#123;    while (1)    &#123;        Swait(FCFS, 1, 1);        Swait(reader_left, 1, 1,         rw_mutex, 1, 0);         Ssignal(FCFS, 1);        perform read operation;        Ssignal(reader_left, 1);       &#125;&#125;writer()&#123;    while (1)    &#123;        Swait(FCFS, 1, 1);        Swait(rw_mutex, 1, 1, reader_left, max_reader, 0);         perform write operation;        Ssignal(rw_mutex, 1);        Ssignal(FCFS, 1);     &#125;&#125;\n“写者优先”的含义：\n与读者优先相反，当有写者进程正在访问资源，多个读进程和写进程申请访问资源时，无论读进程是否比写进程先申请访问资源，读进程都要等到所有写进程结束才能开始进行读操作，即——读进程陷入忙等。\n举例来说就是\n进程申请访问资源顺序为：\n写者 1 -&gt; 读者 1 -&gt; 写者 2 -&gt; （后面只有写者）… -&gt; 写者 n\n实际对资源操作的顺序就也是：\n写者 1 -&gt; 写者 2 -&gt; … -&gt; 写者 n -&gt; 读者 1\n为此，在读者优先算法的基础之上引入 writer_wait 信号量。\n“写者优先”算法（伪代码）：\nint max_reader;semaphore reader_left = max_reader;semaphore rw_mutex = 1;semaphore writer_wait = 1;void reader() &#123;    while (1)     &#123;        Swait(reader_left, 1, 1; rw_mutex, 1, 0; writer_wait, 1, 0);        perform read operation;        Ssignal(reader_left, 1);    &#125;&#125;void writer() &#123;    while (1)     &#123;        Swait(writer_wait, 1, 1);        Swait(rw_mutex, 1, 1; reader_left, max_reader, 0);        perform write operation;        Ssignal(writer_wait, 1);        Ssignal(rw_mutex, 1);    &#125;&#125;\n睡觉理发师问题（如图所示）：一个理发店有一个理发师，一张理发椅子，多张等待椅子（可以假定为n&gt;1张）。当没有顾客的时候，理发师就睡觉。当一个顾客来到店里是，如果理发师在睡觉，则叫醒理发师；如果理发师正在给人理发，则坐在椅子上等待。\n6、回答：题干所述安排有发生竞争的可能吗？如果没有，请予以证明。如果有，什么情况下会发生竞争？利用记录型信号量给出同步算法：如果等待的椅子都满了，则顾客仍然在理发店等待理发；\n竞争情况：\n\n多个顾客竞争同一把空等待椅子 -&gt; 将等待椅子作为临界资源，定义为一个互斥锁\n理发师邀请顾客上理发椅子，多个顾客竞争理发椅子 -&gt; 为理发椅子设置互斥锁，并将等待椅子设为队列结构\n\n流程图（左顾客，右理发师）：\n\n \n\n算法：\n#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define CHAIRS 5#define CUSTOMER 7//全局变量和信号量static int wait[CHAIRS];  //等待椅子队列int in = 0;int out = 0;int rest = CUSTOMER; //总剩余顾客数量sem_t customers;    //记录等候理发的顾客数，用作阻塞理发师进程sem_t barbers;    //记录理发师数，用作阻塞顾客进程sem_t mutex;    //用于理发椅子临界区互斥sem_t mutex2;  //用于等待椅子临界区互斥sem_t wait_seat;  //记录等待椅子数，用作阻塞排队顾客进程void prepare() &#123;    printf(&quot;\\t\\t\\t\\t\\t理发师准备中\\n&quot;);    sleep(3);&#125;void *barber(void *arg) &#123;    while (1) &#123;        sem_wait(&amp;customers);    //若无顾客,理发师睡眠        sem_wait(&amp;mutex);      //防止后来的顾客抢先坐上理发椅子        sem_post(&amp;barbers);   //表示空闲可以进行理发 \t        printf(&quot;\\t\\t\\t\\t\\t理发师邀请%d号椅子顾客上座, %d号椅子空出\\n&quot;, wait[out], wait[out]);        wait[out] = 0;\t\t\t\tout = (out+1)%CHAIRS;\t\t\t\tsem_post(&amp;mutex);        prepare();            &#125;    pthread_exit(NULL);&#125;void get_cut() &#123;    printf(&quot;\\t\\t\\t\\t\\t理发师准备完毕, 顾客正在理发\\n&quot;);    sleep(3);&#125;void *customer(void *arg) &#123;    sem_wait(&amp;wait_seat);  //若没有空的等待椅子，一直等待    sem_wait(&amp;mutex2);     //防止多个顾客坐上同一个等待椅子    wait[in] = in+1;      //坐上等待椅子    printf(&quot;有新顾客入座%d号椅子，剩余%d位顾客\\n&quot;, wait[in], --rest);    in = (in+1) % CHAIRS;    sem_post(&amp;customers);    //待理发顾客+1    sem_post(&amp;mutex2);    sem_wait(&amp;barbers);    //等待没有在理发的理发师    sem_wait(&amp;mutex);    sem_post(&amp;wait_seat);    get_cut();        printf(&quot;\\t\\t\\t\\t\\t理发结束，顾客离开\\n\\n&quot;);    sem_post(&amp;mutex);    pthread_exit(NULL);&#125;int main(int argc, char const *argv[]) &#123;    int res = 0;    int i;    sem_init(&amp;customers, 0, 0);    //顾客初始为0位    sem_init(&amp;barbers, 0, 0);    //理发师在睡觉    sem_init(&amp;mutex, 0, 1);    //理发椅子的互斥锁    sem_init(&amp;mutex2, 0, 1);  //等待椅子的互斥锁    sem_init(&amp;wait_seat, 0, CHAIRS);  //等待椅子的互斥锁    pthread_t bar, cus[6];    res += pthread_create(&amp;bar, NULL, barber, NULL);    for (i = 0; i &lt; CUSTOMER; i++) &#123;        res += pthread_create(&amp;cus[i], NULL, customer, NULL);    &#125;    if (res != 0) &#123;        printf(&quot;线程创建失败！\\n&quot;);        pthread_exit(NULL);    &#125;    pthread_join(bar,NULL);    for (i = 0; i &lt; CUSTOMER; i++) &#123;    \t\tpthread_join(cus[i], NULL);    &#125;    return 0;&#125;\n7、回答：题干所述安排有发生竞争的可能吗？如果没有，请予以证明。如果有，什么情况下会发生竞争？利用记录型信号量给出同步算法：如果等待的椅子都满了，则顾客就离开理发店而不理发了。\n要点：\n(1) 顾客到达：顾客在进入理发店时先检查是否有等待椅子（通过waiting信号量）。\n如果有，顾客会占用一个等待椅子，并唤醒理发师。如果没有等待椅子，顾客会离开。\n(2) 理发师工作：理发师在等待顾客（通过barber信号量）。当有顾客到来时，理发师开始工作。\n(3) 互斥：使用mutex信号量确保对共享资源的安全访问。\n竞争原因：\n(1) 资源有限：1 个理发椅子，n 个等待椅子\n(2) 理发师状态有两种：睡觉、理发\n(3) 顾客操作有两种：到来时理发师在睡觉，叫醒理发师；理发师在理发，坐在等待椅子上\n竞争情况：\n(1) 如果多个顾客同时到达并发现理发师在睡觉，可能会同时尝试叫醒理发师。此时需要一个互斥锁来确保只有一个顾客能够成功叫醒理发师。\n(2) 如果等待椅子已满，而新的顾客到达，可能会发生竞争。\n解决思路：\n(1) 使用互斥锁保护对理发师状态（睡觉或理发中）的修改。\n(2) 使用信号量控制等待椅子的使用，当有空位时允许顾客入座，否则顾客直接离开。\n(3) 使用条件变量实现理发师的唤醒和休眠机制。\n\n算法：\nconst int chairs = n;semaphore customers = 0, barber = 1, mutex = 1;int waiting = 1;barber() &#123;  do&#123;    P(customers);\t\t// 有顾客来被叫醒    P(mutex);    waiting--;    V(mutex);    理发;    V(barber);\t// 理完了可以让其他顾客来理  &#125;&#125;customer() &#123;  do &#123;    P(mutex);    if (waiting &lt; chairs) &#123;\t// 有位置      waiting ++;      V(customers);\t\t\t\t\t// 等待前面的人理完发      V(mutex);      P(barber);\t\t\t\t\t\t// 等到理发师并占用      理发;    &#125; else &#123;\t\t\t\t\t\t\t\t// 没位置      V(mutex);\t\t\t\t\t\t\t// 走人    &#125;  &#125;&#125;\n8、前趋图中的同步应用\n(1) 设有三个进程，input进程、compute进程和output进程；它们通过共享一个缓冲区buf的合作关系如下：\n（a）input进程每次输入数据后，把数据送到buf，供compute进程计算和output进程打印；\n（b）comput进程每次从buf取出已输入的可计算的数据进行计算，并当output进程把输入数据打印完成后，把计算结果送入buf供output进程打印；\n（c）output进程每次把buf中要打印的数据在打印机上输出。\n请给出能正确实现这三个进程同步关系的的进程同步算法。\n(2) 求一元二次方程 ax2+bx+c = 0 的根：x1 = (-b+sqrt(b*b – 4*a*c)) / (2*a) ; x2 = (-b-sqrt(b*b – 4*a*c)) / (2*a)。现把计算分解为如下 6 个可并发执行的过程：请分析这 6 个过程的同步关系，画出前趋图，并用P、V操作实现它们的同步。\nP1:  d1 = 4*a*c;\nP2:  d2 = b*b;\nP3:  d3 = 2*a;\nP4:  d4 = sqrt ( d2 – d1);\nP5:  x1 = (-b+d4) / d3;\nP6:  x2 = (-b-d4) / d3。\n(1) 同步要求：在 compute 从 buf 中取出数据进行计算之前，input 进程必须先把数据送入 buf；output 进程只能在 compute 完成数据的计算并将其存入 buf 后，才可以从 buf 中读取数据并打印；output 进程打印完后，input 进程才能继续向 buf 中写入新的数据。\n同步算法：\n#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;int buf;sem_t empty;\t// 缓冲区是否空sem_t mutex;\t// 访问 buf 的互斥锁sem_t full;\t\t// 缓冲区是否满sem_t compute;// 计算是否完成void* input_process(void* arg) &#123;  while (1) &#123;    sem_wait(&amp;empty);\t// 等待缓冲区为空    sem_wait(&amp;mutex);\t// 进入临界区，互斥访问缓冲区    // 模拟输入    buf = rand() % 100;    printf(&quot;Input Process: Input data %d to buffer\\n&quot;, buf);    sem_post(&amp;mutex);\t// 退出临界区    sem_post(&amp;full);\t// 缓冲区满，通知 compute  &#125;&#125;void* compute_prcess(void* arg) &#123;  while(1) &#123;    sem_wait(&amp;full);\t// 等待缓冲区有数据    sem_wait(&amp;mutex);\t// 进入临界区，互斥访问缓冲区    // 模拟计算过程    int data = buf;    print(&quot;Compute Process: Compute data %d, result %d\\n&quot;, data, data * 2);    buf = data * 2;    sem_post(&amp;mutex);\t\t// 退出临界区    sem_post(&amp;compute);\t// 计算完成，通知 output  &#125;&#125;void* output_process(void* arg) &#123;  while (1) &#123;    sem_wait(&amp;compute);\t// 等待计算结果    sem_wait(&amp;mutex);\t\t// 进入临界区，互斥访问缓冲区    // 模拟输出过程    int data = buf;    printf(&quot;Output Process: Print data %d\\n&quot;, data);    sem_post(&amp;mutex);\t\t// 退出临界区    sem_post(&amp;empty);\t\t// 打印完成，通知 input 进程可以写入新数据  &#125;&#125;int main() &#123;  // 初始化信号量  sem_init(&amp;empty, 0, 1);  sem_init(&amp;full, 0, 0);  sem_init(&amp;compute, 0, 0);  sem_init(&amp;mutex, 0, 1);    // 创建线程  pthread_t tid1, tid2, tid3;  pthread_create(&amp;tid1, NULL, input_process, NULL);  pthread_create(&amp;tid2, NULL, compute_process, NULL);  pthread_create(&amp;tid3, NULL, output_process, NULL);    // 等待线程执行  pthread_join(tid1, NULL);  pthread_join(tid2, NULL);  pthread_join(tid3, NULL);    // 销毁信号量  sem_destroy(&amp;empty);  sem_destroy(&amp;full);  sem_destroy(&amp;compute);  sem_destroy(&amp;mutex);    return 0;&#125;\n(2) 同步关系：P4 依赖 P1 和 P2 的结果。P5 和 P6 依赖 P3 和 P4 的结果。\n前趋图：\n\nPV 操作：\n#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;math.h&gt;double a;double b;double c;double x1;double x2;double d1;double d2;double d3;double d4;sem_t s1;sem_t s2;sem_t s3;sem_t s4;sem_t s5;sem_t s6;void* P1(void* arg) &#123;  d1 = 4 * a * c;  printf(&quot;P1: d1 = 4 * a * c = %.2f\\n&quot;, d1);  sleep(1);  sem_post(&amp;s1);\t// P1 完成，通知 P4 可以继续，后同不过多赘述  return NULL;&#125;void* P2(void* arg) &#123;  d2 = b * b;  printf(&quot;P2: d2 = b * b = %.2f\\n&quot;, d2);  sleep(1);  sem_post(&amp;s2);  return NULL;&#125;void* P3(void* arg) &#123;  d3 = 2 * a;  printf(&quot;P3: d3 = 2 * a = %.2f\\n&quot;, d3);  sleep(1);  sem_post(&amp;s3);  sem_post(&amp;s4);  return NULL;&#125;void* P4(void* arg) &#123;  printf(&quot;P4: wait P1 and P2...\\n&quot;);  sleep(1);  sem_wait(&amp;s1);  sem_wait(&amp;s2);  d4 = sqrt(d2 - d1);  printf(&quot;P4: d4 = sqrt(d2 - d1) = %.2f\\n&quot;, d4);  sleep(1);  sem_post(&amp;s5);  sem_post(&amp;s6);  return NULL;&#125;void* P5(void* arg) &#123;  printf(&quot;P5: wait P3 and P4...\\n&quot;);  sleep(1);  sem_wait(&amp;s3);  sem_wait(&amp;s5);  x1 = (-b + d4) / d3;  printf(&quot;P5: x1 = (-b + d4) / d3 = %.2f\\n&quot;, x1);  sleep(1);  return NULL;&#125;void* P6(void* arg) &#123;  printf(&quot;P6: wait P3 and P4...\\n&quot;);  sleep(1);  sem_wait(&amp;s4);  sem_wait(&amp;s6);  x2 = (-b - d4) / d3;  printf(&quot;P6: x2 = (-b + d4) / d3 = %.2f\\n&quot;, x2);  sleep(1);  return NULL;&#125;int main () &#123;  // 输入一元二次方程的系数  printf(&quot;Enter coefficients a, b, and c for the equation ax^2 + bx + c = 0: \\n&quot;);  scanf (&quot;%lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c);  \t// 初始化信号量  sem_init(&amp;s1, 0, 0);  sem_init(&amp;s2, 0, 0);  sem_init(&amp;s3, 0, 0);  sem_init(&amp;s4, 0, 0);  sem_init(&amp;s5, 0, 0);  sem_init(&amp;s6, 0, 0);\t  // 创建线程  pthread_t tid1, tid2, tid3, tid4, tid5, tid6;  pthread_create(&amp;tid1, NULL, P1, NULL);  pthread_create(&amp;tid2, NULL, P2, NULL);  pthread_create(&amp;tid3, NULL, P3, NULL);  pthread_create(&amp;tid4, NULL, P4, NULL);  pthread_create(&amp;tid5, NULL, P5, NULL);  pthread_create(&amp;tid6, NULL, P6, NULL);    // 等待线程执行完毕  pthread_join(tid1, NULL);  pthread_join(tid2, NULL);  pthread_join(tid3, NULL);  pthread_join(tid4, NULL);  pthread_join(tid5, NULL);  pthread_join(tid6, NULL);    // 销毁信号量  sem_destroy(&amp;s1);  sem_destroy(&amp;s2);  sem_destroy(&amp;s3);  sem_destroy(&amp;s4);  sem_destroy(&amp;s5);  sem_destroy(&amp;s6);    // 输出结果  printf(&quot;The roots of the equation are: x1 = %.2f, x2 = %.2f\\n&quot;, x1, x2);    return 0;&#125;\n9、Linux/Unix的信号机制（软中断）\n阅读下面的程序：（1）给出程序执行的结果，并指出程序执行所对应的进程数。（2）在Linux环境下，给出输入编辑源程序（设文件名为prg2.c）、编译和执行此目标程序的shell命令。\n#include &lt;stdio.h&gt;#include &lt;signal.h&gt;func()&#123;\tprintf(“A signal has been received\\n”);&#125;main()&#123;\tint i ;\tsignal(18,func);\tprintf(‘Processing signal function has been set\\n”);\ti = fork();\tif (i = = 0)  &#123;     \tpringf(“Child process is now executing!\\n”);\t\t\tkill(getppid(),18);\t\t\tsleep(10);\t\t\tprintf(“child finished\\n”);\t\t \texit();\t&#125;\tsleep(10);\tprintf(“This is the parent\\n”);\tkill(i,18);\twait();\tprintf(‘parent finished\\n”);\texit();&#125;\n概念扫盲：\nLinux 信号（signal）是操作系统中用于进程间通信、处理异常等情况的一种机制，属于软件中断。其允许进程之间、进程和内核之间传递异步事件通知，是实现多任务并发执行和进程管理的重要基础。信号类型分为 POSIX 标准信号和 POSIX 实时信号。\n信号的产生与传递过程：\n\n\n通过中断案件产生信号\n\n\n调用系统函数向进程发送信号\n\n\n由软件条件产生信号\n\n\n硬件异常产生信号\n\n\n信号机制核心函数：\nsignal(): void signal**(int signum , void *func(int)); 通过signal函数让信号signum和func关联以后，进程只要接收到signum的信号，不管其正在执行程序的哪一部分，就立即执行** void *func(int) 函数。函数执行结束后，控制权返回进程被中断的那一点继续执行。\nfork(): 如果执行成功， fork()返回给父进程的是子进程的标识符（pid）；返还给子进程的是 0；创建失败返回 – 1。\nkill(): int kill**(** pid_t pid , int signum**)**; 执行了kill( )调用后，进程pid_t pid向发送内容为int signum的信号。\nPS: 虽然在头文件&lt;signal.h&gt;中各种信号被定义为正整数（信号编号），但由于不同操作系统中不同信号的编号也不同，因此建议在实际程序中使用信号的完整名字来代替信号编号。\n回答问题：\n(1)\n代码：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void func(int i)//func()&#123;\tprintf(&quot;%d:A signal has been received\\n&quot;, getpid());&#125;main()&#123;\tint i;\tsignal(SIGUSR1,func);\tprintf(&quot;Processing signal function has been set\\n&quot;);\ti = fork();\tif(i &gt; 0)\t&#123;\t\tprintf(&quot;Parent: %d\\n&quot;,getpid());\t&#125;\tif(i == 0)\t&#123;\t\tprintf(&quot;Child: %d\\n&quot;,getpid());\t&#125;\tif (i == 0)\t&#123; \t\tprintf(&quot;Child process:%d is now executing!\\n&quot;,getpid());\t\tkill(getppid(),SIGUSR1);\t\tsleep(10);\t\tprintf(&quot;child:%d finished\\n&quot;,getpid());\t\texit(0);\t&#125;\tsleep(10);\tprintf(&quot;This is the parent: %d \\n&quot;,getpid());\tkill(i,SIGUSR1);\twait();\tprintf(&quot;parent: %d finished\\n&quot;,getpid());\texit(0);&#125;\n运行结果：\nProcessing signal function has been setParent: 8764Child: 8765Child Process: 8765 is now executing!8764: A signal has been receivedThis is the parent: 87648765: A signal has been receivedchild: 8765 finishedparent: 8764 finished\n运行图示：\n\nS: signal\tP: Print\tF: fork\tK: kill\n(2)\n$ vi prg2.c# 编辑源程序$ g++ -o prg2.o prg2.c$ ./prg2.o\n10、Linux/Unix的信号机制（软中断）。\n阅读下面的程序：（1）给出程序执行的结果；若删除含有“第二次设置处理方式语句 ”标记的语句，给出程序执行的结果，请比较并说明程序执行的结果。（2）指出程序执行所对应的进程数。\n#include &lt;signal.h&gt;void func()&#123;    printf(“This is func\\n”);&#125;main()&#123;  int i , j ;  signal(SIGUSR1,func);  /* 第一次设置处理方式语句 */  while (i = fork() == -1) ;  /* 创建第一个子进程 */  if (i == 0)\t&#123;     sleep(5);    signal(SIGUSR1,func);  /* 第二次设置处理方式语句（要删除的地方） */\t\tprintf(“This is the first child\\n”);  \tsleep(5);  \texit();\t&#125;  while (j = fork() == -1);\t  /* 创建第二个子进程 */  if (j ==0)\t&#123;      \tsleep(3);\t\t\tprintf(“This is the second child\\n”);\t\t\tkill(i , SIGUSR1);\t\t\tsleep(3);\t\t\texit( );\t&#125;  printf(“This is the parent\\n”);\tkill(j , SIGUSR1);\twait();\tkill(i , SIGUSR1);\twait();\texit();&#125;\n(1) 运行结果：\nThis is the parent\t\t\t\t\t父进程启动并执行This is func\t\t\t\t\t\t\t\t第二个子进程（j）处理 SIGUSR1 信号This is the second child\t\t第二个子进程（j）继续执行This is func\t\t\t\t\t\t\t\t第一个子进程（i）处理 SIGUSR1 信号This is the first child\t\t\t第一个子进程（j）继续执行This is func\t\t\t\t\t\t\t\t第一个子进程（i）处理 SIGUSR1 信号\n删除含有“第二次设置处理方式语句 ”标记的语句的运行结果同上\n原因：i. 默认信号处理：信号是异步事件，每个信号（例如 SIGUSR1）在同一时间只能处理一次。当一个进程接收到信号时，它会根据当前设置的处理函数来处理该信号。\nii. 子进程的继承：子进程继承了父进程中的信号处理（即“第一次设置处理方式语句）\niii. 信号发送顺序：父进程给子进程各只发送了一次信号\niv. 信号的处理状态：signal(SIGUSR1, func); 是用来告诉进程如何处理 SIGUSR1 信号，但这与信号的实际发送无关。即使调用多次 signal()，它只是覆盖了之前的处理方式，而不会导致多次处理同一个信号。\n(2) 原程序的进程数是 3\n删除了第二条信号处理的设置，这不会改变进程的创建逻辑和数量。因此，程序的总进程数仍然是 3。\n\n","tags":["OS"]}]